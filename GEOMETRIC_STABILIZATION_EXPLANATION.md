пше # Геометрическая стабилизация при автопосадке - Пошаговое объяснение

## Общая идея

Геометрическая стабилизация - это метод, который **точно вычисляет**, какие изменения тяги нужны каждому двигателю, чтобы создать желаемый момент для коррекции вращения корабля. Вместо использования фиксированных правил (например, "увеличить левые двигатели для коррекции крена"), метод решает систему уравнений на основе реальных позиций двигателей.

---

## Проблема, которую решаем

**Задача**: Корабль наклонен влево (крен). Нужно его выровнять.

**Простое решение** (дифференциальная тяга):
- Увеличить тягу левых двигателей
- Уменьшить тягу правых двигателей
- Корабль вращается вправо → выравнивается

**Проблема простого решения**:
- Не учитывает реальные позиции двигателей
- Не учитывает наклон двигателей
- Не работает оптимально для нестандартных конфигураций
- Может создавать нежелательные моменты по другим осям

**Геометрическое решение**:
- Учитывает точные позиции всех двигателей
- Учитывает направления двигателей
- Вычисляет оптимальные изменения тяги
- Минимизирует нежелательные эффекты

---

## Шаг 1: Определение желаемого момента

**Код**: `StabilizeRotation()` → строки 1586-1593

```csharp
Vector3 correctionAxis = Vector3.Cross(currentUp, desiredUp);
float torqueStrength = geometryTorqueStrength;
float torqueDamping = geometryTorqueDamping;
Vector3 desiredTorque = correctionAxis * torqueStrength - angularVelocity * torqueDamping;
```

### Что происходит:

**Шаг 1.1: Вычисление оси коррекции**
```csharp
Vector3 correctionAxis = Vector3.Cross(currentUp, desiredUp);
```

**Визуализация**:
```
     desiredUp (↑)
         |
         |
    currentUp (↗)
         |
         |
    correctionAxis (→) - перпендикулярно плоскости между векторами
```

**Пример**:
- `currentUp = (0.7, 0.7, 0)` - корабль наклонен вперед-вправо
- `desiredUp = (0, 1, 0)` - хотим вертикально
- `correctionAxis = Cross((0.7, 0.7, 0), (0, 1, 0)) = (0, 0, -0.7)` - ось коррекции назад

**Шаг 1.2: Вычисление желаемого момента**
```csharp
Vector3 desiredTorque = correctionAxis * torqueStrength - angularVelocity * torqueDamping;
```

**Формула**:
```
τ_desired = correctionAxis × torqueStrength - angularVelocity × torqueDamping
```

**Две части**:
1. **Коррекция ориентации**: `correctionAxis * torqueStrength` - момент для поворота к желаемой ориентации
2. **Демпфирование**: `-angularVelocity * torqueDamping` - момент для замедления текущего вращения

**Пример**:
- `correctionAxis = (0, 0, -0.7)`
- `torqueStrength = 2000`
- `angularVelocity = (0.1, 0, 0.05)` - корабль вращается
- `torqueDamping = 200`
- `desiredTorque = (0, 0, -0.7) * 2000 - (0.1, 0, 0.05) * 200 = (0, 0, -1400) - (20, 0, 10) = (-20, 0, -1410)`

**Результат**: Нужен момент `(-20, 0, -1410)` Nm для коррекции.

---

## Шаг 2: Вычисление момента от каждого двигателя

**Код**: `ApplyTorqueWithThrust()` → строки 1353-1364

### Шаг 2.1: Для каждого двигателя вычисляем момент на единицу тяги

```csharp
for (int i = 0; i < engineCount; i++)
{
    Transform engineTransform = shipController.GetEngineTransform(i);
    Vector3 r = engineTransform.position - centerOfMass;  // Рычаг
    Vector3 forceDir = -engineTransform.forward;          // Направление силы
    Vector3 torquePerThrust = Vector3.Cross(r, forceDir * maxThrustForce);
    torqueColumns[i] = torquePerThrust;
}
```

### Физика:

**Момент от двигателя**:
```
τ = r × F
```

где:
- `r` - вектор от центра масс до двигателя (рычаг)
- `F` - сила двигателя

**Сила двигателя**:
```
F = thrust × maxThrustForce × direction
```

где:
- `thrust` - процент тяги (0-1)
- `maxThrustForce` - максимальная сила двигателя
- `direction` - направление силы (противоположно направлению двигателя)

**Момент на единицу тяги**:
```
τ_per_thrust = r × (maxThrustForce × direction)
```

Это момент, который создает двигатель при `thrust = 1.0`.

### Пример:

**Двигатель 0 (передний-левый)**:
- Позиция: `(2, 0, 3)` относительно центра масс
- Направление: `(0, -1, 0)` (вниз)
- `maxThrustForce = 100000N`

**Вычисление**:
```
r = (2, 0, 3)
forceDir = (0, 1, 0)  // Противоположно направлению двигателя
torquePerThrust = Cross((2, 0, 3), (0, 100000, 0))
                = (2, 0, 3) × (0, 100000, 0)
                = (-300000, 0, 200000)
```

**Интерпретация**:
- Компонента X = -300000 → создает момент вокруг оси вперед (roll вправо)
- Компонента Z = 200000 → создает момент вокруг оси вправо (pitch вверх)

**Результат**: `torqueColumns[0] = (-300000, 0, 200000)`

---

## Шаг 3: Построение матрицы преобразования

**Код**: `ApplyTorqueWithThrust()` → строки 1368-1385

### Шаг 3.1: Создание матрицы 3×3

```csharp
float m00 = 0f, m01 = 0f, m02 = 0f;
float m10 = 0f, m11 = 0f, m12 = 0f;
float m20 = 0f, m21 = 0f, m22 = 0f;

for (int i = 0; i < engineCount; i++)
{
    Vector3 c = torqueColumns[i];
    m00 += c.x * c.x;  // Сумма квадратов X компонентов
    m01 += c.x * c.y;  // Сумма произведений X и Y
    m02 += c.x * c.z;  // Сумма произведений X и Z
    m10 += c.y * c.x;  // Симметрично
    m11 += c.y * c.y;
    m12 += c.y * c.z;
    m20 += c.z * c.x;
    m21 += c.z * c.y;
    m22 += c.z * c.z;
}
```

### Что это означает:

**Матрица M**:
```
M = Σ(torqueColumns[i] ⊗ torqueColumns[i])
```

где `⊗` - внешнее произведение (тензорное произведение).

**В развернутом виде**:
```
M = [
    [Σ(c_i.x²),  Σ(c_i.x * c_i.y),  Σ(c_i.x * c_i.z)],
    [Σ(c_i.y * c_i.x),  Σ(c_i.y²),  Σ(c_i.y * c_i.z)],
    [Σ(c_i.z * c_i.x),  Σ(c_i.z * c_i.y),  Σ(c_i.z²)]
]
```

### Зачем это нужно:

Эта матрица описывает, как изменения тяги двигателей преобразуются в изменения момента.

**Математически**:
```
Δτ = M × Δthrust
```

где:
- `Δτ` - изменение момента (вектор 3D)
- `Δthrust` - изменения тяги двигателей (вектор N-мерный, где N - количество двигателей)
- `M` - матрица преобразования (3×N)

**Метод наименьших квадратов**:
Мы используем метод наименьших квадратов для решения переопределенной системы (3 уравнения, N неизвестных, где N ≥ 3).

**Нормальное уравнение**:
```
M^T × M × Δthrust = M^T × Δτ
```

где `M^T` - транспонированная матрица.

**Упрощение**:
Если мы строим матрицу `M^T × M` напрямую, получаем матрицу 3×3, которую можно инвертировать.

---

## Шаг 4: Инверсия матрицы

**Код**: `TryInvertMatrix3x3()` → строки 1429-1461

### Шаг 4.1: Вычисление определителя

```csharp
float det = m00 * (m11 * m22 - m12 * m21)
          - m01 * (m10 * m22 - m12 * m20)
          + m02 * (m10 * m21 - m11 * m20);
```

**Формула определителя матрицы 3×3**:
```
det = a(ei - fh) - b(di - fg) + c(dh - eg)
```

где матрица:
```
[a  b  c]
[d  e  f]
[g  h  i]
```

### Шаг 4.2: Проверка вырожденности

```csharp
if (Mathf.Abs(det) < 1e-6f)
{
    return false;  // Матрица вырождена, нельзя инвертировать
}
```

**Если определитель ≈ 0**:
- Матрица вырождена (необратима)
- Это означает, что двигатели не могут создать момент в некоторых направлениях
- Например, все двигатели на одной линии или все направлены одинаково

### Шаг 4.3: Вычисление обратной матрицы

```csharp
float invDet = 1f / det;
i00 = (m11 * m22 - m12 * m21) * invDet;
i01 = (m02 * m21 - m01 * m22) * invDet;
i02 = (m01 * m12 - m02 * m11) * invDet;
// ... и так далее
```

**Формула обратной матрицы**:
```
M⁻¹ = (1/det) × adj(M)
```

где `adj(M)` - присоединенная матрица (матрица алгебраических дополнений).

**Результат**: Обратная матрица `M⁻¹`, которая позволяет решить систему уравнений.

---

## Шаг 5: Решение системы уравнений

**Код**: `ApplyTorqueWithThrust()` → строки 1395-1399

```csharp
Vector3 v = new Vector3(
    i00 * desiredTorqueWorld.x + i01 * desiredTorqueWorld.y + i02 * desiredTorqueWorld.z,
    i10 * desiredTorqueWorld.x + i11 * desiredTorqueWorld.y + i12 * desiredTorqueWorld.z,
    i20 * desiredTorqueWorld.x + i21 * desiredTorqueWorld.y + i22 * desiredTorqueWorld.z
);
```

### Что происходит:

**Умножение обратной матрицы на желаемый момент**:
```
v = M⁻¹ × τ_desired
```

**В развернутом виде**:
```
v.x = i00 * τ.x + i01 * τ.y + i02 * τ.z
v.y = i10 * τ.x + i11 * τ.y + i12 * τ.z
v.z = i20 * τ.x + i21 * τ.y + i22 * τ.z
```

**Вектор `v`** - это решение системы уравнений. Он описывает, какие "коэффициенты" нужны для создания желаемого момента.

---

## Шаг 6: Вычисление изменений тяги для каждого двигателя

**Код**: `ApplyTorqueWithThrust()` → строки 1402-1424

```csharp
for (int i = 0; i < engineCount; i++)
{
    float target = baseThrust;
    if (valid[i])
    {
        float delta = Vector3.Dot(torqueColumns[i], v);
        delta = Mathf.Clamp(delta, -maxDeltaThrust, maxDeltaThrust);
        target = baseThrust + delta;
    }
    
    target = Mathf.Clamp01(target);
    if (minThrust > 0f)
    {
        target = Mathf.Max(target, minThrust);
    }
    
    currentEngineThrusts[i] = Mathf.MoveTowards(currentEngineThrusts[i], target, maxChange);
    shipController.SetEngineThrust(i, currentEngineThrusts[i]);
}
```

### Шаг 6.1: Вычисление изменения тяги

```csharp
float delta = Vector3.Dot(torqueColumns[i], v);
```

**Скалярное произведение**:
```
delta = torqueColumns[i] · v
```

**Что это означает**:
- Проецирует момент двигателя на решение `v`
- Показывает, насколько нужно изменить тягу этого двигателя

**Пример**:
- `torqueColumns[0] = (-300000, 0, 200000)` - момент двигателя 0
- `v = (0.001, 0, -0.002)` - решение системы
- `delta = Dot((-300000, 0, 200000), (0.001, 0, -0.002)) = -300000*0.001 + 0*0 + 200000*(-0.002) = -300 - 400 = -700`

**Интерпретация**: Нужно уменьшить тягу двигателя 0 на 0.7 (если `maxThrustForce` нормализован).

### Шаг 6.2: Ограничение изменения

```csharp
delta = Mathf.Clamp(delta, -maxDeltaThrust, maxDeltaThrust);
```

**Зачем**:
- Предотвращает слишком резкие изменения тяги
- Обеспечивает плавность работы
- `maxDeltaThrust = 0.25` означает, что тяга может измениться максимум на 25%

### Шаг 6.3: Вычисление целевой тяги

```csharp
target = baseThrust + delta;
```

**Логика**:
- Базовая тяга (например, 0.5 для зависания)
- Плюс изменение для создания момента
- Результат - целевая тяга двигателя

### Шаг 6.4: Плавное изменение

```csharp
currentEngineThrusts[i] = Mathf.MoveTowards(currentEngineThrusts[i], target, maxChange);
```

**Плавное изменение**:
- Текущая тяга плавно движется к целевой
- Скорость изменения: `maxChange = thrustChangeRate * changeRateMultiplier * Time.deltaTime`
- Предотвращает резкие скачки

---

## Полный пример работы

### Ситуация:
- Корабль наклонен влево на 10°
- 4 двигателя в квадрантах
- Базовая тяга: 0.5 (для зависания)
- Желаемый момент: `(1000, 0, 0)` Nm (вращение вправо для коррекции)

### Шаг 1: Вычисление моментов двигателей

**Двигатель 0 (передний-левый)**:
- Позиция: `(-2, 0, 3)` относительно центра масс
- Направление: `(0, -1, 0)` (вниз)
- `torqueColumns[0] = Cross((-2, 0, 3), (0, 100000, 0)) = (300000, 0, 200000)`

**Двигатель 1 (передний-правый)**:
- Позиция: `(2, 0, 3)`
- Направление: `(0, -1, 0)`
- `torqueColumns[1] = Cross((2, 0, 3), (0, 100000, 0)) = (-300000, 0, 200000)`

**Двигатель 2 (задний-левый)**:
- Позиция: `(-2, 0, -3)`
- Направление: `(0, -1, 0)`
- `torqueColumns[2] = Cross((-2, 0, -3), (0, 100000, 0)) = (300000, 0, -200000)`

**Двигатель 3 (задний-правый)**:
- Позиция: `(2, 0, -3)`
- Направление: `(0, -1, 0)`
- `torqueColumns[3] = Cross((2, 0, -3), (0, 100000, 0)) = (-300000, 0, -200000)`

### Шаг 2: Построение матрицы

```
M = [
    [Σ(c_i.x²),  Σ(c_i.x * c_i.y),  Σ(c_i.x * c_i.z)],
    [Σ(c_i.y * c_i.x),  Σ(c_i.y²),  Σ(c_i.y * c_i.z)],
    [Σ(c_i.z * c_i.x),  Σ(c_i.z * c_i.y),  Σ(c_i.z²)]
]

M = [
    [360000000000,  0,  0],
    [0,  0,  0],
    [0,  0,  160000000000]
]
```

### Шаг 3: Инверсия матрицы

```
det = 360000000000 * 0 * 160000000000 - ... = 0
```

**Проблема**: Определитель = 0! Матрица вырождена.

**Причина**: Все двигатели направлены одинаково (вниз), поэтому они не могут создать момент вокруг оси Y (yaw).

**Решение**: В реальном коде это обрабатывается, и метод возвращает `false`, переключаясь на fallback метод (дифференциальную тягу).

### Альтернативный пример: Двигатели могут наклоняться

Если двигатели могут наклоняться для горизонтального движения, матрица не будет вырождена.

**Двигатель 0 (наклонен влево)**:
- Направление: `(-0.1, -0.995, 0)` (немного влево)
- `torqueColumns[0] = Cross((-2, 0, 3), (-10000, -99500, 0)) = (298500, 0, 199000)`

**И так далее...**

### Шаг 4: Решение системы

```
v = M⁻¹ × τ_desired
v = M⁻¹ × (1000, 0, 0)
```

**Результат**: `v = (0.00000278, 0, 0)`

### Шаг 5: Вычисление изменений тяги

**Двигатель 0**:
```
delta = Dot((300000, 0, 200000), (0.00000278, 0, 0)) = 0.834
target = 0.5 + 0.834 = 1.334 → Clamp01 → 1.0
```

**Двигатель 1**:
```
delta = Dot((-300000, 0, 200000), (0.00000278, 0, 0)) = -0.834
target = 0.5 - 0.834 = -0.334 → Clamp01 → 0.0
```

**Двигатель 2**:
```
delta = Dot((300000, 0, -200000), (0.00000278, 0, 0)) = 0.834
target = 0.5 + 0.834 = 1.334 → Clamp01 → 1.0
```

**Двигатель 3**:
```
delta = Dot((-300000, 0, -200000), (0.00000278, 0, 0)) = -0.834
target = 0.5 - 0.834 = -0.334 → Clamp01 → 0.0
```

### Результат:

- **Левые двигатели (0, 2)**: тяга = 1.0 (максимум)
- **Правые двигатели (1, 3)**: тяга = 0.0 (минимум)

**Эффект**: Левая сторона создает больший момент → корабль вращается вправо → выравнивается!

---

## Визуализация процесса

```
1. Определение желаемого момента
   │
   ├─ Вычисление ошибки ориентации
   ├─ Вычисление оси коррекции
   └─ Вычисление желаемого момента (коррекция + демпфирование)
   
2. Вычисление моментов двигателей
   │
   ├─ Для каждого двигателя:
   │   ├─ Вычисление рычага (r = позиция - центр масс)
   │   ├─ Вычисление направления силы
   │   └─ Вычисление момента на единицу тяги (τ = r × F)
   
3. Построение матрицы преобразования
   │
   └─ M = Σ(torqueColumns[i] ⊗ torqueColumns[i])
   
4. Инверсия матрицы
   │
   ├─ Вычисление определителя
   ├─ Проверка вырожденности
   └─ Вычисление обратной матрицы M⁻¹
   
5. Решение системы уравнений
   │
   └─ v = M⁻¹ × τ_desired
   
6. Вычисление изменений тяги
   │
   ├─ Для каждого двигателя:
   │   ├─ delta = Dot(torqueColumns[i], v)
   │   ├─ Ограничение delta
   │   ├─ target = baseThrust + delta
   │   └─ Плавное изменение тяги
```

---

## Преимущества геометрической стабилизации

1. **Точность**: Точно вычисляет необходимые изменения тяги
2. **Универсальность**: Работает с любым количеством двигателей (≥3) и любым их расположением
3. **Оптимальность**: Минимизирует изменения тяги (метод наименьших квадратов)
4. **Учет геометрии**: Учитывает реальные позиции и направления двигателей
5. **Отсутствие жестких правил**: Не требует знания, какой двигатель где находится

---

## Ограничения и fallback

**Если матрица вырождена** (определитель ≈ 0):
- Метод возвращает `false`
- Автопилот переключается на fallback метод (дифференциальная тяга через фиксированные индексы квадрантов)

**Если двигателей < 3**:
- Метод возвращает `false`
- Недостаточно двигателей для создания момента в 3D

**Если изменения тяги слишком большие**:
- Ограничиваются через `maxDeltaThrust`
- Обеспечивается плавность работы

---

## Ключевые формулы

### Момент от двигателя:
```
τ_i = r_i × F_i
τ_i = r_i × (thrust_i × maxThrustForce × direction_i)
```

### Момент на единицу тяги:
```
τ_per_thrust_i = r_i × (maxThrustForce × direction_i)
```

### Система уравнений:
```
τ_desired = Σ(Δthrust_i × τ_per_thrust_i)
```

### Решение методом наименьших квадратов:
```
M = Σ(τ_per_thrust_i ⊗ τ_per_thrust_i)
v = M⁻¹ × τ_desired
Δthrust_i = Dot(τ_per_thrust_i, v)
```

---

## Итог

Геометрическая стабилизация - это математически точный метод, который решает систему уравнений для вычисления оптимальных изменений тяги двигателей. Он учитывает реальную геометрию корабля и двигателей, что делает его более точным и универсальным, чем простые правила дифференциальной тяги.
